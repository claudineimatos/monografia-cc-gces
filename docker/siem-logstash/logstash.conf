input {
        tcp {
                port => 5000
                type => syslog
        }
        udp {
                port => 5000
                type => syslog
        }
}

filter {
        if [type] == "syslog" {
                grok {
                        patterns_dir => "./patterns"
                        match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
                        add_field => [ "received_at", "%{@timestamp}" ]
                        add_field => [ "received_from", "%{host}" ]
                }
                syslog_pri { }
                date {
                        match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
                        timezone => [ "America/Sao_Paulo" ]
                }

                if [syslog_program] == "sshd" {
                        if [syslog_message] =~ "Accepted %{WORD:auth_method} for" {
                                grok {
                                        break_on_match => true
                                        match => { "syslog_message" => "Accepted %{WORD:auth_method} for %{USER:username} from %{IP:src_ip} port %{INT:src_port} ssh2" }
                                }
                        } else if [syslog_message] =~ "Invalid user" {
                                grok {  
                                        break_on_match => true
                                        match => { "syslog_message" => "Invalid user %{USER:username} from %{IP:src_ip}" }
                                }
                        } else {
				grok { 
                                        match => { "syslog_message" => "%{GREEDYDATA:syslog_message} %{IP:src_ip}" }
				}
			}
                }
        }

        if [src_ip] {
                geoip {
                        source => "src_ip"
                        target => "geoip"
			database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
                        add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
                        add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}" ]
                }
                mutate { 
                        convert => [ "[geoip][coordinates]", "float" ]
                }
        }
}

output {
  #elasticsearch { host => ELASTICSEARCH_HOST }
  stdout { codec => rubydebug }
}
